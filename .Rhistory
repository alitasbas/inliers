}
}
return(clusters_df)
}
x <- clusters(normal_sample)
x
clusters_df <- data.frame(lower_boundary = numeric(0),
upper_boundary = numeric(0),
cluster_size = numeric(0))
clusters_df
clusters_df <- add_row(clusters_df,
lower_boundary=31,
upper_boundary=69,
cluster_size = 3)
clusters_df
clusters_df <- add_row(clusters_df,
lower_boundary=31,
upper_boundary=69,
cluster_size = 5)
clusters_df
clusters <- function(sample) {
n <- length(sample)
sample <- sort(sample)
diffs <- diff(sample)
# Find the ideal diff length
round_index <- 5
for (i in round_index:-5) {
if (between(as.matrix(table(round(diffs, i)))[1], 0.08 * n, 0.12 * n)) {
round_index <- i
print(round_index)
break
}
}
diffs_table <- as.matrix(table(round(diffs, round_index)))
diffs_table <- as.data.frame(diffs_table)
diffs_table$difference <- as.double(rownames(diffs_table))
colnames(diffs_table) <- c("frequency", "difference")
threshold <- diffs_table[3, 2]
binary_diffs <- c(as.integer(diffs <= threshold), 0, 0) # 1 if the distance < threshold
# Find the number of connected data points
clusters_df <- data.frame(lower_boundary = numeric(0),
upper_boundary = numeric(0),
cluster_size = numeric(0))
c_size <- 0
next_point_index <- 0
for (point_index in 1:(n-1)) {
cat("checking index", point_index, "\n")
if (point_index <= next_point_index) {
next
}
if (binary_diffs[point_index] == 1) {
for (next_point_index in (point_index + 1): (n-1)) {
cat("Matched. Now checking trailing indexes", next_point_index, "\n")
print(binary_diffs[next_point_index:(next_point_index + 2)])
print(sum(binary_diffs[next_point_index:(next_point_index + 2)]))
if (sum(binary_diffs[next_point_index:(next_point_index + 2)]) == 0) {
cluster_boundaries <- c(point_index, (next_point_index - 1))
cat("cluster_boundaries: ", cluster_boundaries, "\n")
c_size <- sum(binary_diffs[cluster_boundaries[1]: cluster_boundaries[2]])
if (c_size < 3) {
cat("skipped at", point_index, "\n")
}
else {
print("Adding to dataframe")
clusters_df <- add_row(clusters_df,
lower_boundary=cluster_boundaries[1],
upper_boundary=cluster_boundaries[2],
cluster_size = c_size)
}
break
}
} # end of for(next_point_index) loop
}
}
return(clusters_df)
}
x <- clusters(normal_sample)
x
qchisq(0.5, 4)
qchisq(0.5, 4, lower.tail = F)
qchisq(0.5, 4, lower.tail = T)
qchisq(0.5, 2, lower.tail = T)
# Akkaya Inlier generation
generate_contaminated_vectorized <- function(n) {
# Generate and Sort
x <- sort(rnorm(n))
# Calculate Mean
emean <- mean(x)
# Indices for the bottom 10%
n2 <- round(0.1 * n)
# Create the output vector
x1 <- x
# Create a sequence for i: 1, 2, ..., n2
i_seq <- 1:n2
# Calculate the corresponding j indices (end of array)
j_seq <- n - i_seq + 1
# Apply formula to Head (bottom 10%)
x1[i_seq] <- emean + (-0.01)^i_seq
# Apply formula to Tail (top 10%)
x1[j_seq] <- emean + (-0.01)^j_seq
return(x1)
}
generate_contaminated_data <- function(n) {
# 1. RNNOR: Generate Random Normal
x <- rnorm(n)
# 2. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- 0.0
for (i in 1:n) {
emean <- emean + x[i]
}
emean <- emean / n
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.01)^i
term_j <- (-0.01)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
generate_contaminated_data <- function(n) {
# 1. RNNOR: Generate Random Normal
x <- rnorm(n)
# 2. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- 0.0
for (i in 1:n) {
emean <- emean + x[i]
}
emean <- emean / n
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.01)^i
term_j <- (-0.01)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
generated_contaminated_sample(100)
generate_contaminated_data <- function(n) {
# 1. RNNOR: Generate Random Normal
x <- rnorm(n)
# 2. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- 0.0
for (i in 1:n) {
emean <- emean + x[i]
}
emean <- emean / n
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.01)^i
term_j <- (-0.01)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
generate_contaminated_sample(100)
generate_contaminated_data(100)
hist(generate_contaminated_data(100))
plot(density(generate_contaminated_data(100)))
plot(density(generate_contaminated_data(100)))
plot(density(generate_contaminated_data(100)))
plot(density(generate_contaminated_data(100)))
plot(density(generate_contaminated_data(100)))
plot(density(generate_contaminated_data(100)))
ns <- rnorm(100)
plot(density(generate_contaminated_data(ns)))
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.01)^i
term_j <- (-0.01)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
plot(density(generate_contaminated_data(ns)))
ns <- rnorm(100)
plot(density(generate_contaminated_data(ns)))
ns <- rnorm(100)
plot(density(generate_contaminated_data(ns)))
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.01)^i
term_j <- (-0.01)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(generate_contaminated_data(ns)))
plot(density(ns))
plot(density(generate_contaminated_data(ns)))
plot(density(ns))
plot(density(generate_contaminated_data(ns)))
plot(density(generate_contaminated_data(ns)))
plot(density(ns))
par(mfrow=c(1, 2))
plot(density(generate_contaminated_data(ns)))
plot(density(ns))
par(mfrow=c(1, 1))
lines(density(ns))
plot(density(generate_contaminated_data(ns)))
lines(density(ns))
lines(density(ns))
plot(density(generate_contaminated_data(ns)))
plot(density(ns))
lines(density(generate_contaminated_data(ns)))
plot(density(ns), ylim=c(0, 1))
lines(density(generate_contaminated_data(ns)))
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)))
legend()
legend("topleft")
legend("topleft", legend = c("Orgnl", "Inlier"), hue=c("blue", "red"))
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"))
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"))
legend(locator(1), legend = c("Orgnl", "Inlier"), col=c("blue", "red"))
legend("topleft", legend = c("Linear", "Quadratic"), col = c("blue", "red"), lty = 1)
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"), lty=1)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)))
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"), lty=1)
lines(density(generate_contaminated_data(ns)), col="red")
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.1)^i
term_j <- (-0.1)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.5)^i
term_j <- (-0.5)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"), lty=1)
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-1)^i
term_j <- (-1)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.75)^i
term_j <- (-0.75)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.88)^i
term_j <- (-0.88)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.88)^i
term_j <- (-0.88)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"), lty=1)
generate_contaminated_data <- function(x) {
# 1. SVRGN: Sort the data
# In your code, X1 is sorted and copied to X.
# So effectively, X becomes the sorted array.
x <- sort(x)
# 3. Calculate Mean (Loop 566)
emean <- mean(x)
# 4. Calculate Bounds (n2)
# int(0.5 + 0.1*n) is the manual way to round to the nearest integer
n <- length(x)
n2 <- round(0.1 * n)
# Initialize X1 to match X initially
x1 <- x
# 5. Modify the Tails (Loop 50)
# This replaces the top and bottom 10% with a deterministic value
for (i in 1:n2) {
j <- n - i + 1
# (-0.01)**i
term_i <- (-0.91)^i
term_j <- (-0.91)^j
x1[i] <- emean + term_i
x1[j] <- emean + term_j
}
# Loop 51 (Copying middle) is redundant here because we
# initialized x1 <- x, but logically, the middle 80% remains x.
return(x1)
}
ns <- rnorm(100)
plot(density(ns), ylim=c(0, 1), col="blue", label="original")
lines(density(generate_contaminated_data(ns)), col="red")
legend("topleft", legend = c("Orgnl", "Inlier"), col=c("blue", "red"), lty=1)
source("utils.R")
getwd()
pwd()
setwd("D:\ODTU\Sem 7\STAT 499\R")
setwd("D:/ODTU/Sem 7/STAT 499/R")
source("utils.R")
